<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mles.io</title>
<link rel="stylesheet" href="https://gitcdn.link/repo/Chalarangelo/mini.css/master/dist/mini-default.min.css" />
<style>
#bwidth {
    margin: auto;
    width: 85%;
    padding: 10px;
}
</style>
</head>
<body>
<div class="container">
<div id="bwidth">
<div>
<img src="images/mles_logo_final.png" alt="Mles logo" width="100" /><h2>Mles overview</h2>
</div>
<p><b>Mles</b> (<i>Modern Lightweight channEl Service</i>) is a lightweight, robust and fast authenticated distributed publish/subscribe data service based on Rust (a safe, concurrent and fast systems language), Tokio (asynchronous networking for Rust) and Serde (serialization framework for Rust). It works seamlessly with IPv4 or IPv6 on TCP, which provides its reliable data transfer backbone on Rust supported platforms, including Linux, OSX and Windows.</p>

<p>Mles is based on <i>Mles protocol</i> (IANA port# 8077) which has a lightweight header structure with SipHash based authentication. The reference server implementation is lock-free (no blocking!) and supports strong session authentication between Mles client and server. With its two layer authentication scheme (1st level: server-client, 2nd level: client-client) it provides possibility for clients to authenticate each others independently from servers and also to build any additional protocol over Mles they may need. </p>

<p>Mles data structure is based on CBOR (Concise Binary Object Representation). It consists of (<i>uid, channel, message</i>) value triplet where <i>uid</i> and <i>channel</i> are UTF-8 strings and <i>message</i> can be of any type of payload.</p>

<p>Mles servers can be connected together by defining peer servers. This provides a simple but yet powerful way to distribute data between servers.</p>

<p>Mles example client provides also simple WebSocket proxy implementation which allows to use Mles without opening additional public ports, if that is not in some cases feasible.</p>

<p>For more information about Mles reference implementation, see <a href="https://github.com/jq-rs/mles-rs">https://github.com/jq-rs/mles-rs</a>.</p>

<h2>Use cases</h2>

<p>Often it is important that any data can be distributed in a scalable and properly authenticated but still reliable way. These services can take advantage using Mles as a backbone service. In a common case a client is connected directly to a public server. Another common use case is with two servers, one public server and one internal server which peers the public server. Clients connect either to the internal server or public server directly. There is not much limits as such, though, so feel free to try any setup you need.</p>

<p>Services that could have most benefit of the Mles could be e.g. configuration distribution or IoT telemetry. For a giant large scale services, such a data distribution service combined with a proper TCP offload engine (TOE) may provide a highly scalable service. E.g. telemetry collection between any number of devices and servers could be very efficient that way.</p>

<h2>Future development</h2>

<p>In the future reference implementation may be enhanced with new services, e.g. means to do hitless server upgrade with peer server backup support or assisting client. Even more scalable multi-core versions could be provided as a separate release although current implementation should scale very well on most use cases with proper distribution. </p>

<p>Changes to the Mles protocol itself are not allowed after 1.0 release as a simple protocol means lightweight, compatible and understandable service.</p>

<p>On client side of course any new type of service can be introduced as a 2nd level service.</p>
</div>
</div>
</body>
</html>


