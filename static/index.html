<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mles.io</title>
<link rel="stylesheet" href="https://gitcdn.link/repo/Chalarangelo/mini.css/master/dist/mini-default.min.css" />
<style>
#bwidth {
    margin: auto;
    width: 85%;
    padding: 10px;
}
</style>
</head>
<body>
<div class="container">
<div id="bwidth">
<div>
<img src="images/mles_logo_final.png" alt="Mles logo" width="100" /><h2>Mles overview</h2>
</div>
<p><b>Mles</b> (<i>Modern Lightweight channEl Service</i>) is a lightweight, robust and fast authenticated distributed publish/subscribe data service based on Rust (a safe, concurrent and fast systems language), Tokio (asynchronous networking for Rust) and Serde (serialization framework for Rust). It works seamlessly with IPv4 or IPv6 on TCP, which provides its reliable data transfer backbone on Rust supported platforms, including Linux, OSX and Windows.</p>

<p>Mles is based on <i>Mles protocol</i> (IANA port# 8077) which has a lightweight header structure with SipHash based authentication. The reference server implementation is lock-free (no blocking!) and supports strong session authentication between Mles client and server. With its two layer authentication scheme (1st level: server-client, 2nd level: client-client) it provides possibility for clients to authenticate each others independently from servers and also to build any additional protocol over Mles they may need. </p>

<p>Mles data structure is based on CBOR (Concise Binary Object Representation). It consists of (<i>uid, channel, message</i>) value triplet where <i>uid</i> and <i>channel</i> are UTF-8 strings and <i>message</i> can be of any type of payload.</p>

<p>Mles servers can be connected together by defining peer servers. This provides a simple but yet powerful way to distribute data between servers.</p>

<p>Mles example client provides also simple WebSocket proxy implementation which allows to use Mles without opening additional public ports, if that is not in some cases feasible.</p>

<p>For more information about Mles reference implementation, see <a href="https://github.com/jq-rs/mles-rs">https://github.com/jq-rs/mles-rs</a>.</p>

<h2>Use cases</h2>

<p>Often it is important that any data can be distributed in a scalable and properly authenticated but still reliable way. These services can take advantage using Mles as a backbone service. In a simple use case clients are connected directly to a public server. Another common use case is with more servers, one public server and several internal servers which peer the public server. Clients connect either to one of the internal servers or public server directly. Feel free to try any tree-like setup you need.</p>

<p>Services that could have benefit of the Mles could be e.g. configuration distribution or IoT telemetry. For a giant large scale services, such a data distribution service combined with a proper TCP offload engine (TOE) should provide a highly scalable service. In general any publish/subscribe type service without the need of database on the service itself can be seen as a fine candidate as an user.</p>

<h2>Future development</h2>

<p>In the future reference implementation may be enhanced with performance and resiliency improvements. Other extensions may be considered too as long as they do not change the general principles of Mles.</p>

<p>Changes to the Mles protocol itself are not allowed after 1.0 release as a simple protocol means lightweight, compatible and understandable service.</p>

<p>On client side of course any new type of service can be introduced as a 2nd level service.</p>
</div>
</div>
</body>
</html>


